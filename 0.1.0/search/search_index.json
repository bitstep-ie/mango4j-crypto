{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mango4J Crypto","text":"mango4j-crypto <ul> <li>Official Guide</li> <li>Encryption Delegates</li> <li>General Documentation on Application Level Encryption</li> <li>Mango4J Crypto Example Application</li> </ul>"},{"location":"delegates/aws-delegate/","title":"AWS Encryption Service Delegate","text":"<p>This delegate allows applications to use the Amazon Web Services Key Management Service  for cryptographic operations. It does this by providing a simple wrapper around the  AWS KMS SDK.</p> <p>NOTE: AWS KMS has a message limit of 4kb so it is not suitable for encrypting larger payloads.    See note about limitations below</p> <p>The key type for this delegate is \"AWS_KMS\", so associated CryptoKeys must have their  type set to that value.</p> <p>The following are the fields that must be included in your Cryptokey configuration </p> <p><pre><code>{\n  \"awsKeyId\": \"&lt;&lt;Your AWS KMS key ARN/key Identifier&gt;&gt;\",\n  \"algorithm\" : \"&lt;&lt;AWS KMS ALGORITHM&gt;&gt;\"\n}\n</code></pre>  Supported algorithms for encryption/decryption currently are: SYMMETRIC_DEFAULT  Supported algorithms for HMAC generation currently are: HMAC_SHA_224, HMAC_SHA_256, HMAC_SHA_384, HMAC_SHA_512,   </p>"},{"location":"delegates/aws-delegate/#aws-kms-limitations","title":"AWS KMS Limitations","text":"<p>For applications which need to encrypt payloads larger than 4k and also want more control over how cryptographic operations  are carried out, Amazon also provide an  AWS Encryption SDK which  integrates with AWS KMS to provide client side cryptographic  operations. This client side approach includes creating Data Encryption Keys for each encryption operation and  wrapping (encrypting) them with the AWS KMS master key. Since mango4j-crypto already has support for wrapped key  encryption we currently do not provide any delegate support for the AWS Encryption SDK. If you want to use the envelope  approach you can just use the  Wrapped Key Encryption Service Delegate  with an AWS_KMS (this delegate) CryptoKey as the wrapping key.  For performance critical functionality you can also check out the  Cache Wrapped Key Encryption Service Delegate  with an AWS_KMS (this delegate) CryptoKey as the wrapping key</p>"},{"location":"delegates/aws-delegate/#how-to-use","title":"How to Use","text":"<p>Add the following dependency to your pom</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;ie.bitstep.mango&lt;/groupId&gt;\n    &lt;artifactId&gt;mango4j-crypto-aws-delegate&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Then just create an instance of  AwsEncryptionServiceDelegate  with a configured KmsClient and add it to the list of delegates you configure with your CryptoShield. For example a Spring configuration might look like this:</p> <p><pre><code>@Configuration\npublic class Config {\n\n    @Value(\"${aws.access.key.id}\")\n    public String accessKeyId;\n\n    @Value(\"${aws.secret.access.key}\")\n    public String secretAccessKey;\n\n    @Value(\"${aws.region}\")\n    public String awsRegion;\n\n    @Bean\n    public AwsEncryptionServiceDelegate awsEncryptionServiceDelegate() {\n        return new AwsEncryptionServiceDelegate(KmsClient.builder()\n            .region(Region.of(awsRegion))\n            .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n            .credentialsProvider(StaticCredentialsProvider.create(AwsBasicCredentials.builder()\n            .accessKeyId(accessKeyId)\n            .secretAccessKey(secretAccessKey)\n            .build()))\n        .build());\n    }\n\n    @Bean\n    public CryptoShield cryptoShield(CryptoKeyProvider cryptoKeyProvider,\n                                 List&lt;EncryptionServiceDelegate&gt; encryptionServiceDelegates) {\n        return new CryptoShield.Builder()\n            .withAnnotatedEntities(List.of(MyConfidentialEntity.class))\n        .withCryptoKeyProvider(cryptoKeyProvider)\n            .withEncryptionServiceDelegates(encryptionServiceDelegates)\n            .withObjectMapperFactory(new ConfigurableObjectMapperFactory())\n            .build();\n    }\n}\n</code></pre> </p>"},{"location":"delegates/aws-delegate/#mango4j-crypto-example","title":"mango4j-crypto-example","text":"<p>See the mango4j-crypto-example for  a working example of using this delegate.   Just add the aws-kms-encryption profile in the active  Spring profiles section of the application.yml file. Then pass in your values for the  aws.access.key.id, aws.secret.access.key and aws.region properties.</p>"},{"location":"delegates/core-delegates/","title":"Production Delegates","text":""},{"location":"delegates/core-delegates/#pbkdf2-encryption-service-delegate","title":"PBKDF2 Encryption Service Delegate","text":"<p>The PBKDF2EncryptionService is a provided EncryptionServiceDelegate implementation that uses the JDKs Java Cryptography Architecture (JCA) for encryption and decryption. This is a real encryption service that could be used for production deployments (make sure to store the pass phrase in a secure manner) and can also be useful for testing purposes. It supports various encryption algorithms, modes and padding schemes that are available in the JDK. You can configure these values by configuring the appropriate attributes in the CryptoKey configuration map. An example CryptoKey definition for the PBKDF2EncryptionService would be as follows:</p> <p><pre><code>{\n    \"id\": \"&lt;&lt;some-unique-key-id&gt;&gt;\",\n    \"type\" : \"PBKDF2\",\n    \"usage\" : \"ENCRYPTION\",\n    \"configuration\" : {\n      \"keySize\": 128,\n      \"algorithm\": \"AES\",\n      \"mode\": \"GCM\",\n      \"padding\": \"NoPadding\",\n      \"iterations\": 10,\n      \"gmTagLength\": 128,\n      \"passPhrase\": \"&lt;&lt;my-secure-passphrase&gt;&gt;\",\n      \"ivSize\": \"12\",\n      \"salt\": \"16\"\n  },\n  ......other CryptoKey fields\n}\n</code></pre> </p>"},{"location":"delegates/core-delegates/#wrapped-key-encryption-service-delegate","title":"Wrapped Key Encryption Service Delegate","text":"<p>The WrappedKeyEncryptionService is a provided EncryptionServiceDelegate implementation that uses the JDKs Java Cryptography Architecture (JCA) for encryption and decryption using a uniquely generated key for each encryption operation. This key is \"wrapped\" (encrypted) with the wrapping key. This is the same approach that other providers such as the AWS Encryption SDK (they call it envelope encryption) to carry out encryption operations locally but keeping the generated keys secure. So to break it down, it works like this:</p> <p>Everytime encrypt is called, a new random key is generated for the encryption operation. This key is then encrypted (wrapped) with the wrapping key and stored in the ciphertext along with the encrypted data. When decrypting, the library extracts the wrapped key from the ciphertext, decrypts (unwraps) it with the wrapping key to get the original generated key and then uses that key to decrypt the data. This approach allows you to have a unique key for each encryption operation while still keeping those keys secure with a wrapping key. The configuration for using this encryption service is a bit more complex than the PBKDF2EncryptionService as you need to have both a wrapping CryptoKey and a content CryptoKey configured in your system and you need to specify which one is which in their configurations. Please see the javadocs for the WrappedKeyEncryptionService and the CryptoKey class for more details on how to configure this encryption service.</p> <p>Here is an example of a Wrapped Crypto Key: <pre><code>{\n\"id\": \"&lt;&lt;some-unique-key-id&gt;&gt;\",\n\"type\" : \"WRAPPED\",\n\"usage\" : \"ENCRYPTION\",\n\"configuration\" : {\n    \"kek\" : \"&lt;&lt;some-unique-key-id-of-the-wrapping-encryption-key&gt;&gt;\",\n    \"ivSize\": \"12\",\n    \"keySize\": 128,\n    \"algorithm\": \"AES\",\n    \"mode\": \"GCM\", \n    \"padding\": \"NoPadding\",\n    \"gmTagLength\": 128\n},\n......other CryptoKey fields\n}\n</code></pre></p> <p>And here is an example of the corresponding Wrapping Crypto Key: <pre><code>{\n\"id\": \"&lt;&lt;some-unique-key-id-of-the-wrapping-encryption-key&gt;&gt;\",\n\"type\" : \"BASE64\",\n\"usage\" : \"ENCRYPTION\",\n\n  ......other CryptoKey fields\n}\n</code></pre></p> <p>NOTE: Notice how in the WRAPPED CryptoKey configuration (the first one) we specify the 'kek' attribute which is the ID of the wrapping key (the 2nd one) that should be used for this wrapped key ('kek' stands for Key Encryption Key).</p> <p>In the example CryptoKey pair above we use the base64 encryption service for the wrapping key just for simplicity of the example, but in a production deployment you would use a real encryption service for the wrapping key such as an implementation of the EncryptionServiceDelegate that uses your cloud provider's Key Management Service (KMS) for encryption operations.  </p>"},{"location":"delegates/core-delegates/#cached-wrapped-key-encryption-service-delegate","title":"Cached Wrapped Key Encryption Service Delegate","text":"<p>The CachedWrappedKeyEncryptionService is a provided EncryptionServiceDelegate implementation that works almost the same way as the WrappedKeyEncryptionService except for that it caches keys in memory for a certain period for much better performance. So it is a compromise between security and performance. The keys are stored in an in-memory vault which uses a secret key generated on application startup to offer slightly better protection of the keys while in the cache. This obviously isn't foolproof, if somebody can do a dump of the heap they could potentially track down the vault key and decrypt the keys in the cache. So this should only be used if you have other controls in place to protect against this type of attack and you should also make sure to set the cache period to the minimum that you can get away with in your application. The configuration for using this encryption service is the same as the WrappedKeyEncryptionService (see previous section for example CryptoKey definition) but you also need to specify the cache period in CachedWrappedKeyEncryptionService using the constructor parameters.</p> <p>The relevant constructor parameters are:</p> <p>entryTTL: This is the time to live for each key in the cache for decryption purposes. Once a key has been in the cache for this amount of time it will be evicted from the cache (and the key bytes will be destroyed) and the next time it is needed it will be unwrapped again using the WRAPPING key and re-cached. Set this to the minimum amount of time that you can get away with in your application to minimise the risk of keys being compromised while in the cache.  currentEntryTTL: This is the time to live for the current encryption key in the cache. Whereas the WrappedKeyEncryptionService generates a new Data Encryption Key on every encryption operation, the CachedWrappedKeyEncryptionService generates one and stores it in the cache for subsequent encryption operations until it expires. The currentEntryTTL parameter is the length of time that the current encryption key will be stored in the cache before it expires and a new one is generated. Set this to the minimum amount of time that you can get away with in your application to minimise the risk of keys being compromised while in the cache.  cacheGracePeriod: Short period for which expired keys can remain available to allow for clock skew and to avoid situations where a key is obtained from the cache just before expiration and then the key material subsequently destroyed before the actual encryption/decryption is carried out by the delegate. Set this to a short period of time, like a few seconds.</p> <p>The CachedWrappedKeyEncryptionService is a good option to consider if you want to get the performance benefits of caching for wrapped keys but you also want to have some level of protection for the keys while in the cache. Unlike the WrappedKeyEncryptionService which generates a new Data Encryption Key for every encryption operation and subsequently encrypts that key with the WRAPPING key, the CachedWrappedKeyEncryptionService generates one, encrypts it with the WRAPPING key and stores it in the cache for subsequent encryption operations until it expires. So it can dramatically cut down on calls to the WRAPPING key service for encryption operations.  Likewise, for decryption operations, if the key needed for decryption is in the cache it can be used directly without needing to call the WRAPPING key service to unwrap it first. So this can also cut down on calls to the WRAPPING key service for decryption operations as well.</p>"},{"location":"delegates/test-delegates/","title":"Testing Delegates","text":""},{"location":"delegates/test-delegates/#base64-encryption-service-delegate","title":"Base64 Encryption Service Delegate","text":"<p>The Base64EncryptionService is a provided EncryptionServiceDelegate implementation that simply Base64 encodes the  plaintext and decodes the Base64 string back to plaintext for decryption. This should only be used for testing purposes  and should never be made available in a production deployment. There is no keyConfiguration required for Base64EncryptionService.  </p>"},{"location":"delegates/test-delegates/#identity-encryption-service-delegate","title":"Identity Encryption Service Delegate","text":"<p>The IdentityEncryptionService is a provided EncryptionServiceDelegate implementation that basically does nothing.  It simply stores the plaintext as is and returns the same plaintext for decryption. This should only be used for testing  purposes and should never be made available in a production deployment.  There is no keyConfiguration required for Base64EncryptionService.  </p>"},{"location":"general/general/","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Mango CryptoKey Driven Design<ol> <li>Key Objects</li> <li>Encryption Service Delegates</li> </ol> </li> <li>Ciphertext Representation</li> <li>Key Rotation (Changing the key)<ol> <li>Encryption Key Rotation</li> <li>HMAC Key Rotation</li> </ol> </li> <li>Rekeying (re-encrypting existing records with the new key)</li> <li>HMAC Key Rotation Challenges<ol> <li>Searching operations during the rotation of a HMAC key</li> <li>Unique constraint enforcement</li> </ol> </li> <li>HMAC Strategies<ol> <li>List HMAC Strategy<ol> <li>Process for re-keying data with the List HMAC Strategy</li> </ol> </li> <li>Double HMAC Strategy<ol> <li>Process for re-keying data with the Double HMAC Strategy</li> </ol> </li> </ol> </li> <li>FAQ<ol> <li>What is a tenant?</li> <li>What's a HMAC?</li> <li>What is a hash?</li> <li>What's an IV?</li> <li>Why do I need to HMAC data in order to make it searchable?</li> <li>Why do I need to HMAC confidential data in order to make it unique?</li> <li>What is a key rotation?</li> <li>Why would I perform a key rotation?</li> <li>What does re-keying mean?</li> <li>Why should I re-key?</li> <li>Why does mango4j-crypto-core have the concept of only 1 encryption key but multiple HMAC keys?</li> <li>Why don't HMACs have a reference to the HMAC key stored alongside them the same way encrypted ciphertext does?</li> <li>What is HMAC tokenization?</li> </ol> </li> </ol>"},{"location":"general/general/#introduction","title":"Introduction","text":"<p>This documentation is aimed at providing a more general discussion of implementing encryption in your code.</p> <p>Much of the contents in this document can be used as a reference for developers who need to implement ALE regardless of whether they use mango4j-crypto or not. Developers should consider the guidelines documented in each section when building their own solutions.</p> <p>This documentation purposely avoids talking about specific cryptographic implementations. or standards (AES, PKCS#11, AWS KMS, etc.) because the core focus here is to talk about how to implement ALE (whatever cryptographic methods, standards or providers you use) and what general challenges exist along with guidance on overcoming them in your application.</p> <p>This documentation uses some terms regularly which we'll define upfront:</p> <p>Tenant: A term used to describe logical isolation in your system for a particular client entity. e.g. Some institutions have requirements that any confidential data of theirs that you store in your system should be segregated from data belonging to other entities. An application could spin up a full environment just for that client institution or they can choose to introduce the concept of 'tenants' in the system. With each client entity being a 'tenant' and each 'tenant' using their own encryption keys, the application meets the data segregation guidelines. If you do not use tenants then just consider your application as the tenant.</p> <p>HMAC key: A HMAC is just a hash which uses a secret key to create the hash. HMACs are used for 2 main purposes in an application:</p> <ol> <li>To support searching on fields that are encrypted</li> <li>To support unique constraint enforcement on fields that are encrypted.    The FAQ section at the bottom of this document    explains this in more detail.</li> </ol>"},{"location":"general/general/#mango-crypto-key-driven-design","title":"Mango Crypto-Key Driven Design","text":"<p>Often when designing applications which have to implement Application Level Encryption (ALE) it might seem to make sense to design only with some specific cryptographic provider in mind (e.g. Azure Dedicated HSM) but doing this could introduce complexities later if your application needs the potential to use different providers (different regions might have different cryptographic providers or regulations). You may need to perform a key rotation from one key which uses some cryptographic provider to a new key which uses some other cryptographic provider. Or even just rotate a key to a stronger algorithm, or whatever. So a more flexible design should be used to support a more generic approach to implementing ALE. We call the approach that the mango4j-crypto takes 'Key Driven Design'. The term 'Key Driven Design' comes from the fact that each tenant has a group of encryption/HMAC keys (referred to in this documentation as CryptoKeys) and those CryptoKeys define how the encryption operation is carried out. i.e. If a CryptoKey has a type of 'AWS_KMS' then this library would use AWS KMS and its SDK to perform the encryption operation, if a CryptoKey has a type of 'HSM' then this library will use some matching HSM implementation to perform the encryption operation. This approach hides the details from the application code which is generally good practice and allows for more flexibility if an application needs to use a different method to perform encryption later without needing any changes to existing application code.</p> <p>This library was designed to force application code into a tried and tested design for ALE which removes references to specific cryptographic providers from your code and allows you to handle encryption key rotation and HMAC key rotation more robustly. HMAC key rotation has a long section all of its own in this document which should be considered mandatory reading for all developers who need to HMAC data for lookup or unique constraint purposes.</p>"},{"location":"general/general/#encryption-service-delegates","title":"Encryption Service Delegates","text":"<p>In mango4j-crypto all the code for cryptographic operations is hidden behind an abstraction we refer to as the ' Encryption Service Delegate'. What this means is that an infinite number of approaches can be used to perform the cryptographic operations by allowing developers to supply their own Encryption Service Delegates. Just create your own subclass of the EncryptionServiceDelegate class and implement the abstract methods. Coupled with the CryptoKey objects this allows applications to support multiple types of cryptographic providers or different cryptographic approaches depending on application requirements. This also allows applications to support different cryptographic providers at the same time (e.g. different regions using different providers) without needing to change any application code. And it also allows keys to be rotated from one provider to another without needing to change any application code (and potentially without even restarting the application).   Mang4j-crypto comes with a few built-in Encryption Service Delegate implementations: </p> <ul> <li>Production: Wrapped Delegate, Cache Wrapped Delegate</li> <li>Test: Base64 Delegate, Identity Delegate</li> </ul> <p>And developers can create their own Encryption Service Delegate implementations to suit their needs. If you do create your own Encryption Service Delegates which you think would be universally useful then please consider giving back by making it publicly available, or even submitting a PR to the mango4j-crypto project so that others can benefit from it too.</p>"},{"location":"general/general/#key-objects","title":"Key objects","text":"<p>CryptoKey objects tell the library which Encryption Service Delegate to use to carry out the actual cryptographic operations under the hood. We often see applications representing their encryption/HMAC keys in their code with simple Strings (representing an AWS KMS key ID or key ARN for example) rather than key objects, but representing your key information with objects instead provides much more flexibility with how your encryption works. For example, this library represents keys in the code with the following object:</p> <pre><code>public class CryptoKey {\n    private String id;\n    private CryptoKeyUsage usage;\n    private String type;\n    private Map&lt;String, Object&gt; configuration;\n    private Instant keyStartTime;\n    private RekeyMode rekeyMode;\n    private Instant createdDate;\n    private Instant lastModifiedDate;\n}\n</code></pre> <p>id: Just a plain old random GUID</p> <p>usage: What this key will be used for (either encryption or HMAC)</p> <p>type: The type of the Encryption Service Delegate that this key will use to carry out its cryptographic operations. This must match the value returned from the desired EncryptionServiceDelegate.supportedCryptoKeyType() implementation.  For example: The included CacheWrappedKeyEncryptionService.supportedCryptoKeyType() returns the value \"CACHED_WRAPPED\", so if you wanted to use that Encryption Service Delegate implementation then you would have a CryptoKey object with this 'type' field set to \"CACHED_WRAPPED\". At runtime the library matches the CryptoKeys with their corresponding EncryptionServiceDelegates by comparing this 'type' field. If you create you own Encryption Service Delegate implementation, you can define this field however you like.</p> <p>Configuration: This field stores the information about the key that the Encryption Service Delegates use to carry out their operations. It would never contain the actual bytes of the key or related confidential information (at least not in the clear). Instead, it would usually contain a reference to the key. For example: if the 'type' of this key was AWS_KMS then this map would have an entry called \" keyArn\" with the value of the AWS Key ID or Key ARN. Each Encryption Service Delegate implementation will know what configuration information it needs to carry out its operations so the application just needs to make sure that the right information is present in this map for the given key type.</p> <p>keyStartTime: Optional field which is only used for HMAC CryptoKeys. When used this can alleviate some of the shortcomings with the Single HMAC Strategy that are described further in this document. If you are using this field it should be set when the CryptoKey is created in your application. It's very important to set this to some time in the future which is greater than the key cache time. i.e. by the time this ketStartTime date passes, all application instances should know about this key. </p> <p>  A big advantage of using CryptoKey objects to represent cryptographic key information is that it allows applications to easily support multiple cryptographic providers while keeping code clean and encryption code abstracted. It could also allow you to rotate from one type of key to another (e.g. AWS_KMS to AZURE_DEDICATED_HSM) with no application code changes. Or you could support different encryption delegates in different regions without having to write any custom application code to support that.</p>"},{"location":"general/general/#ciphertext-representation","title":"Ciphertext representation","text":"<p>When CryptoShield.encrypt() is called on an object the library will set the @EncryptedData field in the object to the calculated ciphertext. This final ciphertext is represented in a standardised way for encryption (not HMACs). Instead of just returning the straight ciphertext output it will return it as a JSON String with the following definition:</p> <pre><code>{\n  \"cryptoKeyId\": \"someKeyId\",\n  \"iv\": \"someInitializationVector\",\n  \"data\": {}\n}\n</code></pre> <p>where:</p> <ul> <li>cryptoKeyId is the identifier of the crypto key object (e.g. the CryptoKey.id field) in your system that was used to   carry out the cryptographic operation</li> <li>iv is the Initialization Vector that was used for the cryptographic operation</li> <li>data is the actual output that was returned from the Encryption Service Delegate's encrypt() method, the ciphertext   will be included here.   Each delegate may return different data here depending on the cryptographic provider or method that it uses, or what   information it   defines as necessary to include. This is why it's a map, because it needs to be flexible enough to accommodate   different ciphertext data structures that different EncryptionServiceDelegates define.</li> </ul>"},{"location":"general/general/#key-rotation-changing-the-key","title":"Key Rotation (Changing the key)","text":"<p>Key rotation is the process of changing a CryptoKey to a new CryptoKey. After a key is rotated, create and update operations should use the new key to perform the encryption operations. After a key is rotated, some records will have been encrypted with the previous key (or keys) while some will have been encrypted with the new key. So previous keys should still be available for decryption until there are no more records associated with them.</p> <p>When applications implement Application Level Encryption, they will commonly have to support key rotation. They may have different requirements around how often the CryptoKeys need to be rotated or what conditions trigger a key rotation. But a key rotation should be something which an application can do at short notice on the fly. This is necessary to ensure that no more ciphertext is generated with an old key after we have introduced a new key into the system. Although rotating an encryption key is relatively straight forward, rotating a HMAC key on the other hand can pose considerable challenges (discussed at length further in this documentation)</p>"},{"location":"general/general/#encryption-key-rotation","title":"Encryption Key Rotation","text":"<p>Changing an encryption key is relatively straightforward. Just add the new encryption key to your tenant/system and use it for all write operations going forward. Just make sure to keep the older encryption keys available until no more records exist that were encrypted with those keys. This is also why mango4j-crypto includes the CryptoKey ID in the ciphertext that it generates, so that we always know what key we need to use to decrypt any given piece of ciphertext.</p>"},{"location":"general/general/#hmac-key-rotation","title":"HMAC Key Rotation","text":"<p>HMAC key rotation is a completely different beast and supporting it successfully requires serious application design considerations. Due to this material being so involved we've given it a large section all of its own further in this document. Please read the discussion carefully.</p>"},{"location":"general/general/#rekeying-re-encrypting-existing-records-with-the-new-key","title":"Rekeying (re-encrypting existing records with the new key)","text":"<p>Rekeying is the process whereby after a key rotation we have a background task which decrypts existing records (that were encrypted with some older key) and re-encrypt them with the new key. This is done when you want to completely remove an older key from the system after a key rotation but there are still older records which were encrypted (or have had HMACs calculated) with the older key. In this scenario we cannot remove the older key until there are no more records that have been encrypted with that key. So in order to support the removal of the old key we need to rekey the records which were encrypted with that key onto the new key until there are no more records remaining which were encrypted with the old key. Rekeying is an extremely important function which is needed to handle the scenario in which a key is no longer considered secure, and thus we can no longer tolerate any records having ciphertext which used that key.</p> <p>Mango4j-crypto supports 2 types of rekey modes which are specified using the rekeyMode field on a CryptoKey (please see the relevant section on how to configure the mango4j-crypto automatic rekey job):</p> <p>KEY_OFF: This type of rekey is where we have some encryption/HMAC key that we want to completely remove from our system but there might still be some entities which used that key.</p> <p>NOTE: If rekeyMode is set to 'KEY_OFF' on the current encryption or current HMAC CryptoKey it is ignored. It doesn't really make sense to key off the current key.</p> <p>KEY_ON: This type of rekey is where we want all other encryption/HMAC keys (apart from this one) to be completely removed from the system. This type of rekeying should be strongly reconsidered before initiating it because it will most likely rekey a very large portion of your entities which may have a notable impact on performance. Also, keep in mind that you may need to make sure any external cryptographic providers that you use are aware that they will experience a higher volume of traffic for the period of time that the rekey takes.</p> <p>NOTE: If rekeyMode is set to 'KEY_ON' on a key that is not the current encryption or current HMAC CryptoKey it is ignored. It doesn't really make sense to rekey everything onto some old key.</p> <p>IMPORTANT: Avoid falling into the trap of thinking that shorter data retention rules can save you from having to support rekeying functionality in your application. We've often heard the idea that if an application has a key period of say 10 years but our data retention period is only 5 years that rekey support will not be required and we can just swap the key every 10 years. An easy way to see the flaw in this logic is to ask yourself what happens in year 11 when you change the HMAC key? What about all the records from year 6 to year 10? You now can't find them! Also, with unique constraints you have 5 years of records in your system which may be at risk of duplication.</p>"},{"location":"general/general/#hmac-key-rotation-challenges","title":"HMAC Key Rotation Challenges","text":"<p>The following section documents the 2 core challenges when it comes to supporting HMAC key rotation in your application. It's advised for all developers not familiar with this particular topic to read this section very carefully. It may seem easy to not give much attention to the scenario of rotating HMAC keys, possibly thinking \"when are we really going to need to change a tenant's HMAC key?!\" or \"I can worry about it later\". But hopefully as you can see below, in order to support this functionality there are very important considerations to take into account for the way that you design your application. And the challenges presented by HMAC key rotation can be very difficult to retrofit into an application further down the line.</p>"},{"location":"general/general/#searching-operations-after-the-rotation-of-a-hmac-key","title":"Searching operations after the rotation of a HMAC key","text":"<p>If your application has the concept of a single HMAC key per tenant, it's extremely likely that you'll need to stop doing this and change this design approach. Unless for some reason you don't have to support HMAC key rotation in your application. The reason being that if you change a tenant (or system) HMAC key during normal application operation you won't be able to find any of the existing records. The only way that you could change a tenants HMAC key is if it's acceptable to take your system offline until all records have been re-keyed with the new key by some background job. Or (for some reason) you are able to tolerate a lot of search misses for existing records until such a background job was complete while the application was running. Both of these scenarios are very unlikely to be tolerated in most modern applications.</p> <p>To break down this sample scenario into steps:</p> <ol> <li>You change the HMAC key for your tenant.</li> <li>All application searches going forward will use the new HMAC key.</li> <li>Immediately you won't be able to find any records in your system because all existing HMACs have been calculated with    the old HMAC key</li> <li>You kick off a background job which goes from record to record decrypting and re-keying the fields with the new HMAC    key.</li> <li>Your application searches gradually start to become more and more successful over time.</li> <li>Once the background rotation job is complete your application search functionality is now back online.</li> </ol> <p>The functional search outage from your application is most likely unacceptable. Re-keying all records in your system may take a very large amount of time. You may have a very large number of records in your system and even with a modest number of records, it's generally not acceptable to have this background re-keying job run as fast as it can due to performance degradation of your system. Increased number of calls to the DB (2 extra calls in the background for every record). Not to mention if you're using an external cryptographic provider (like Azure Dedicated HSM) it might not handle (or even allow) the extra traffic without its own performance problems. It may be tempting to think along the lines of running the background job until all records are re-keyed with the new HMAC key before changing the key on the tenant. But this is just the same scenario in reverse. Your application searches will begin successfully but immediately will become less and less successful over time until the background job is finished and you change the tenants HMAC key to the new one.</p> <p>To remedy this you need to implement 2 simple concepts:</p> <ol> <li>Change your design approach so that a tenant has a list of HMAC keys rather than a single HMAC key.    Depending on your application requirements this list may contain anywhere from a single HMAC key to N HMAC keys.    During HMAC key rotations you will add the new HMAC key to the list, instead of replacing the old HMAC key.    If your application doesn't support rekeying then this list of HMAC keys will keep getting larger until one    of the following 2 scenarios happen:        a). Older data that has HMACs calculated with an old key is deleted due to data retention rules. Once there are no    more HMACs in the DB that were calculated with that old HMAC key, it can be removed from the list.        b). You rekey all records onto the new HMAC key. HMAC Rekeying can get tricky and there are multiple ways of doing it    depending on which HMAC strategy you use (described below).</li> </ol> <p> 2. For your application's search operations, change the logic to look for matches with a list of HMACs instead of    trying    to match a single HMAC. The number of HMACs generated for the search will be equal to the number of HMAC keys in the    tenants HMAC key list.    So your code needs to be prepared for this scenario by matching across a list of HMACs rather than a single HMAC.</p> <p>So the steps for converting your design approach to accommodate the above approach would become:</p> <ol> <li>Update your tenant record to have a list of HMACs</li> <li>Modify your application search code in such a way that instead of looking for a HMAC field value equal to the    generated HMAC (e.g. in JpaRepository):</li> </ol> <pre><code>findByUsernameHmac(String userNameHmac);\n</code></pre> <p>Change it to generate a list of HMAC values (using the tenant's list of HMAC keys) and look for a HMAC value which is in that list of HMACs (e.g. in JpaRepository):</p> <pre><code>findByUsernameHmacIn(Collection&lt;String&gt; userNameHmacs);\n</code></pre> <ol> <li>Modify your normal application HMAC code for write operations to choose the active HMAC key for the HMAC    operations from the tenant's HMAC key list (that would be the HMAC key with the most recent CryptoKey.createdDate    field).</li> </ol>"},{"location":"general/general/#however-the-previous-solution-still-has-major-flaws","title":"However, the previous solution still has major flaws!","text":"<p>If your application is a multi-instance application and caches key information (both very likely in modern applications) then very big issues still remain.  Even with the previous solution consider the following scenario:</p>"},{"location":"general/general/#multi-instance-application-with-cached-keys-search-scenario","title":"Multi-instance application with cached Keys search scenario","text":"<ol> <li>You have 2 instances of your application, and they both cache key/tenant information (common practice because this    type of    information rarely changes)</li> <li>You add the new HMAC key to the tenant's list of HMAC keys</li> <li>You kick off a background rekey job</li> <li>Instance 1 of your application has not updated its cache and is still only seeing the tenant with the old HMAC key</li> <li>Instance 2 of your application has updated its cache and is now seeing the tenant with both the old HMAC key and new    HMAC key</li> <li>Instance 2 inserts a new record with an email of <code>john.doe@test.com</code> and uses the new HMAC key to do it (since going    forward the application should use the new HMAC key)</li> <li>A search comes into instance 1, and it uses the old HMAC key to HMAC <code>john.doe@test.com</code> and search for it.</li> <li>The record is not found because the HMAC for <code>john.doe@test.com</code> was calculated and inserted by instance 2 using the    new HMAC key</li> </ol> <p>To solve this issue, another design change needs to be considered. This change is described in the next section and is also needed for another (possibly much more serious) challenge regarding unique constraints. Implementing the design consideration in the next section will also solve the above shortcoming.</p>"},{"location":"general/general/#unique-constraint-enforcement-after-the-rotation-of-a-hmac-key","title":"Unique constraint enforcement after the rotation of a HMAC key","text":"<ul> <li>IMPORTANT!!! - This problem is much more important than the previous search problem! If your application has unique     constraints on     confidential fields then there's a chance that changing a HMAC key could leave your application in a broken state!</li> </ul> <p>If you have a confidential field which you need to be unique for your tenant, let's say....a username field. Then you will have a DB column with a unique constraint where you store the HMAC of this username. Now, if you switch HMAC keys it will be possible to create accounts with the same username. Since an existing account username was calculated with the old HMAC key then a new account could be created with the same username since now that the new HMAC key is being used it will calculate a different HMAC for the same username value and the DB unique constraint will not be enforced. This could have serious repercussions for your system and its data integrity.</p> <p>To break down this sample scenario into steps:</p> <ol> <li>A user exists in your application with username <code>john.doe@test.com</code></li> <li>You change your tenant's HMAC key to the new HMAC key (or if you've followed    the above approach    to solve the search challenge, you've added the new HMAC key into your tenant's list of HMAC keys)</li> <li>A request to create a new user (or change an existing username) is sent to your application with the username    <code>john.doe@test.com</code>.</li> <li>Your application calculates the HMAC of <code>john.doe@test.com</code> using the tenant's new HMAC key. This HMAC will be    different than the username HMAC for the existing <code>john.doe@test.com</code> record.</li> <li>The new record is created (or existing record is updated) successfully as the unique constraint on that DB column    won't have been triggered.</li> <li>There now exists 2 users in the application with the username <code>john.doe@test.com</code></li> </ol> <p>It may be tempting to think that you can offset this somewhat by always searching for the username first before write operations but this impacts performance and makes the DB unique constraint a little bit redundant. However, in any case it doesn't solve the problem. In multi-instance applications which cache key information there would still exist a race condition in your code which can result in 2 usernames with the same value:</p> <ul> <li>Imagine at point 7 in the previous cached keys search   scenario that instead of   searching for a record, instance 1 creates a new record with the   username <code>john.doe@test.com</code>. It can even search for any existing records but it won't find them (because it doesn't   yet   have the latest HMAC key). This situation will result in a duplicate record being created by instance 1.</li> </ul> <p>To remedy this you need to implement particular approaches to calculating and storing the HMACs for your entity fields. The following sections detail some of these approaches, all of which are supported in the mango4j-crypto library.</p>"},{"location":"general/general/#hmac-strategies","title":"HMAC Strategies","text":"<p>There are several designs you can choose to work with HMACs in your code depending on your application's ability to  tolerate or circumvent the challenges documented above (if they apply). So this section will discuss the ones supported  by Mango4j-crypto in the following section. We strongly advise considering the List HMAC Strategy but due to its  unfamiliarity we'll start with the Single HMAC Strategy. </p>"},{"location":"general/general/#single-hmac-strategy","title":"Single HMAC Strategy","text":"<p>This strategy is only recommended if you're aware of the challenges mentioned above and are confident that they do not  apply to your application. The Single HMAC strategy isn't really much of a strategy, it's just the way that many applications (unfortunately in many cases) default to using HMACs. So for each HMAC you have a single column in your table/record where you store the HMAC. So our USER_PROFILE table would simply look like this:</p> ID TENANT_ID CIPHER_TEXT SOME_OTHER_NON_CONFIDENTIAL_ATTRIBUTE USERNAME_HMAC ENCRYPTION_KEY_ID HMAC_KEY_ID 9c7e275e-3729-421c-a7c5-cf02bba17f2d MyTenantID QmFzZTY0RW5jb2RpbmdPZlVzZXJQcm9maWxlQ29uZmlkZW50aWFsQXR0cmlidXRlcw== some value In the clear QmFzZTY0VmFsdWVPZlVzZXJuYW1l 23a0a1b4-3897-4eaa-b8fa-1818a9540f0c 31ae30a7-4228-40a9-9078-d5e994491981 <p>And (as usual) you have a list of HMAC keys on a tenant. However, as mentioned previously this strategy exposes you to the 2 main challenges associated with HMAC key rotation.</p> <p>Those challenges can still be dealt with using this strategy but the trade offs may not be worth it. Let's explore:</p>"},{"location":"general/general/#search-challenge-solution","title":"Search challenge solution","text":"<p>The 1st of the HMAC challenges (search outage) can be dealt with in a fairly simple manner by introducing the concept  of a \"HMAC key start time\". When a new HMAC key is introduced into the system we could set this key start time to  \"the current time + the key cache time\". Then we make sure that the application never performs write operations with  that key until after the \"key start time\". An application would always use all of the HMAC keys it knows about to  perform search operations (regardless of key start times). But since no application would create/update a record with  the new key until all instances know about that key then all instances should be able to find all records including  new/updated ones.</p>"},{"location":"general/general/#unique-constraints-challenge-partial-solution","title":"Unique constraints challenge partial solution","text":"<p>For the 2nd challenge (unique constraint integrity) it can only be narrowed down to a race condition but even then, only  by using a costly trade-off (in addition to using the \"key start time\" concept): forcing the application to perform a search before every write operation.  Let's elaborate with the username scenario:   Before every write operation the application will search (using all HMAC keys) to see if a record already exists with  that username.     . If the record exists then prevent the operation     . If the record does not exist then carry out the operation.  This solution will be unacceptable to many applications as the necessity of performing a search operation before every  single write operation will have a negative impact on performance. As an aside, it also makes any unique constraint  definitions on the database irrelevant for most cases (but not all - so they're still needed).</p> <p>Imagine the following scenario (for even just a single instance application):  * Username <code>john.doe@test.com</code> is not in the system * A new HMAC key has been created in the application with a valid key start time * A request comes in to create a new record for username <code>john.doe@test.com</code> (on thread 1) 1 millisecond before  \"key start time\" * Thread 1 searches for username <code>john.doe@test.com</code> with both HMAC keys  * Username with that HMAC doesn't exist so Thread 1 doesn't find it * Thread 1 decides to insert record using HMAC key 1 (since it's still before the \"HMAC key start time\") * Thread 1 gets paused before insert * A request comes in to create a new record for username <code>john.doe@test.com</code> (on thread 2) 1 millisecond after  \"key start time\" * Thread 2 searches for username <code>john.doe@test.com</code> with both HMAC keys * Username with that HMAC doesn't exist so Thread 2 doesn't find it * Thread 2 decides to insert record using HMAC key 2 (since it's now after the \"HMAC key start time\") * Thread 1 wakes up and inserts the record with HMAC key 1 * Thread 2 inserts the record with HMAC key 2 * Username <code>john.doe@test.com</code> is now duplicated in the system</p> <p>As mentioned previously the Single HMAC Strategy should only be used for applications which do not use HMACs for unique  constraint requirements. Even then there's a better strategy for not only unique constraint integrity but also for  a more powerful search support. But please consider the challenges above when deciding which HMAC strategy is right for your application.</p> <p> </p> <p>Pros of the Single HMAC strategy:</p> <ul> <li>Probably the simplest design possible for supporting HMACs in an application</li> <li>Relational DB friendly, single table design</li> <li>No performance impact on write operations. Only calculates and inserts a single HMAC (per attribute)    for each write operation</li> <li>Not much of a window for process (human) error during a key rotation or re-keying job.</li> </ul> <p>Cons of the Single HMAC strategy:</p> <ul> <li>Cannot support applications which require both unique constraint enforcement and key rotation without serious drawbacks.</li> <li>Without \"key start time\" a key rotation will cause intermittent search outages for applications which cache HMAC keys.</li> <li>Without \"key start time\" unique constraints cannot be supported.</li> <li>Even with \"key start time\" unique constraint support requires performance degradation.</li> <li>Can never fully support unique constraint integrity under all circumstances.</li> </ul>"},{"location":"general/general/#list-hmac-strategy","title":"List HMAC strategy","text":"<p>This strategy documents the most general and powerful design that application developers can use to take care of all problems mentioned above. Using this design guarantees your application will accommodate HMACs correctly regardless of your use case or application requirements. The List HMAC strategy has just 2 fairly elegant concepts:</p> <ol> <li>Have a list of HMAC keys on your tenant, rather than a single HMAC key. Exactly as already discussed in this    document.</li> <li>For all write operations write the entire list of generated HMACs into your DB.</li> </ol> <p>Part 2 is the tricky bit because when you use an SQL DB, it forces you into a particular entity design. If you take our previous examples where we HMAC the username. This would mean that we would have a table for the actual record (maybe a USER_PROFILE table) with the encrypted ciphertext and whatever other information, a table for lookup HMACs if we are using the username HMAC for search purposes (e.g. USER_PROFILE_LOOKUPS) and a 3rd table for unique values ( USER_PROFILE_UNIQUE_VALUES) if we are using the username HMAC to enforce uniqueness per tenant.</p> <p>For example the USER_PROFILE table might look like this:</p> ID TENANT_ID CIPHER_TEXT SOME_OTHER_NON_CONFIDENTIAL_ATTRIBUTE ENCRYPTION_KEY_ID 9c7e275e-3729-421c-a7c5-cf02bba17f2d MyTenantID QmFzZTY0RW5jb2RpbmdPZlVzZXJQcm9maWxlQ29uZmlkZW50aWFsQXR0cmlidXRlcw== some value In the clear 23a0a1b4-3897-4eaa-b8fa-1818a9540f0c <p>And the USER_PROFILE_LOOKUPS table would look like this:</p> ID TENANT_ID ALIAS VALUE HMAC_KEY_ID USER_PROFILE_ID 2f2ab2f4-57cb-441a-84c8-44eee23e3693 MyTenantID username QmFzZTY0VmFsdWVPZlVzZXJuYW1l 31ae30a7-4228-40a9-9078-d5e994491981 9c7e275e-3729-421c-a7c5-cf02bba17f2d <p>And the USER_PROFILE_UNIQUE_VALUES tables would look like this:</p> ID TENANT_ID ALIAS VALUE HMAC_KEY_ID USER_PROFILE_ID eeddbee1-34db-4554-ada4-a23e04c69846 MyTenantID username QmFzZTY0VmFsdWVPZlVzZXJuYW1l 31ae30a7-4228-40a9-9078-d5e994491981 9c7e275e-3729-421c-a7c5-cf02bba17f2d <p>The USER_PROFILE_LOOKUPS and USER_PROFILE_UNIQUE_VALUES look exactly the same because they are. The only reason they need to be separate is because the USER_PROFILE_UNIQUE_VALUES table needs a compound unique constraint placed on the TENANT_ID, ALIAS, VALUE and HMAC_KEY_ID columns, whereas the lookup does not.</p> <p>With the above entity design when inserting or updating records in the USER_PROFILE table, your application code would generate a list of HMACs (1 for each HMAC key in use) and insert them all into both the USER_PROFILE_LOOKUPS and USER_PROFILE_UNIQUE_VALUES tables (1 row per HMAC entry). If you now go back to the HMAC challenge scenarios described earlier in this document (even the cached keys scenario), you'll see that this design guarantees to overcome both. If you're using a document DB such as Mongo, you should just implement this design anyway as it won't interfere with your entity design. The USER_PROFILE_LOOKUPS and USER_PROFILE_UNIQUE_VALUES tables just become separate lists inside the USER_PROFILE record. Unfortunately when using relational DBs this strategy will require inserting/updating from 1 to 3 separate tables for each write operation and for searching it will require a join from the USER_PROFILE_LOOKUPS table back to the original record in the USER_PROFILE table.</p>"},{"location":"general/general/#process-for-re-keying-data-with-the-list-hmac-strategy","title":"Process for re-keying data with the List HMAC Strategy","text":"<ol> <li>Add your new HMAC key to the tenant's list of HMAC keys</li> <li>Wait until the HMAC key cache expiry time has passed (if applicable), so that all application instances are using the    new HMAC key.</li> <li>Kick off the re-keying job.</li> <li>The re-keying job should find each record it needs to re-key. This depends on application requirements but will    probably fall into one of 2 criteria:    a. Any record which doesn't yet have HMACs calculated with the new HMAC key - common for full re-keying of all data    **    b. Any record which has HMACs calculated with some old HMAC key (that you're trying to remove from the system), but    does not have HMACs calculated with the new HMAC key -    common for passive key rotation**</li> <li>For each record found, decrypt the record, calculate the HMAC(s) with the new key, insert the HMAC(s) into the    lookup/unique constraint tables (or add them to the lists if    using a document DB and save the record). Existing HMACs should remain as they are, untouched.</li> <li>Wait for all applicable records to be re-keyed</li> <li>Remove the old HMAC key from the tenant's list of HMAC keys</li> <li>Wait until the HMAC key cache expiry time has passed (if applicable), so that all application instances are no longer    using the old HMAC key.</li> <li>For every record, remove all HMACs from the lookup/unique constraint tables (or document HMAC entries) that were    calculated with the old HMAC key. Leaving them there won't    affect functionality so this cleanup step is optional from a functionality perspective, but leaving old HMACs in your    system is a potential security hazard so applications    should perform this step at least for long-lived data.</li> <li>You can now delete the old HMAC key from wherever it was stored.</li> </ol> <p>Pros of the list HMAC strategy:</p> <ul> <li>Bulletproof HMAC design which will work for all combinations of application requirements</li> <li>The only general HMAC design which supports passive key rotation for long-lived data which uses HMACS for unique value   enforcement</li> <li>Application search code becomes standardized and is cleaner (because all lookups tables will have the same definition)</li> <li>Excellent fit for document DBs (Mongo)</li> <li>Supports zero-outage search</li> <li>Supports unique constraint integrity</li> <li>Supports applications which cache HMAC keys</li> <li>Supports all passive key rotation designs</li> <li>Easiest strategy for supporting re-keying of data with no impact to application functionality</li> <li>Can have as many HMAC keys on a tenant as you want. You can add a new HMAC key anytime you want, even in the middle of   a re-keying job, and it won't affect application   functionality.</li> <li>Easily supports HMAC tokenization.</li> </ul> <p>Cons of the list HMAC strategy:</p> <ul> <li>Forces relational DBs into a multi-table entity design which can negatively impact performance</li> <li>Always adds/updates N HMACs for each write operation, where N is the number of HMAC keys in use. So depending on the   rate at which an application deletes old keys this will have   a performance impact if the list of HMAC keys keeps growing.</li> </ul>"},{"location":"general/general/#double-hmac-strategy","title":"Double HMAC strategy","text":"<p>The Double HMAC strategy is a compromise between the List HMAC strategy and the (mostly not recommended) Single HMAC Strategy (or its sister strategy the Single Time Based HMAC strategy) that allows for a more normal entity design.</p> <p>This strategy trades the generality of the List HMAC strategy to a more simple relational design and has an added downside of only allowing 2 HMAC keys to be in use for write operations at any time. So there will be some applications which this strategy won't suit, particularly those that need to have 3 or more HMAC keys active for write operations at any time. Applications which use HMACs for unique value enforcement for long-lived data and only support passive key rotation (no re-keying) cannot use this strategy. For applications which require unique value enforcement, using this strategy will mean that you must support re-keying old data because if you need to introduce a new HMAC key (once you already have 2 HMAC keys) then you're forced to re-key any HMACs that were calculated with the oldest HMAC key (1rst HMAC key) onto the most recent HMAC key (2nd HMAC key) before you can introduce the new (3rd HMAC key)....and so on.</p> <p>The way the strategy works is the following. You just have the USER_PROFILE table, but it looks like this:</p> ID TENANT_ID CIPHER_TEXT SOME_OTHER_NON_CONFIDENTIAL_ATTRIBUTE USERNAME_HMAC_1 USERNAME_HMAC_2 ENCRYPTION_KEY_ID HMAC_KEY_ID_1 HMAC_KEY_ID_2 9c7e275e-3729-421c-a7c5-cf02bba17f2d MyTenantID QmFzZTY0RW5jb2RpbmdPZlVzZXJQcm9maWxlQ29uZmlkZW50aWFsQXR0cmlidXRlcw== some value In the clear QmFzZTY0VmFsdWVPZlVzZXJuYW1l QmFzZTY0VmFsdWVPZlVzZXJuYW1l 23a0a1b4-3897-4eaa-b8fa-1818a9540f0c 31ae30a7-4228-40a9-9078-d5e994491981 31ae30a7-4228-40a9-9078-d5e994491981 <p>Notice that there are 2 separate columns for the username HMAC. With this strategy, your application will assume that there could be up to 2 write keys (max) in use at any time so that it can be prepared to insert 2 HMACs for the username for each write operation. With the HMAC generated with the old key inserted into the USERNAME_HMAC_1 column and the HMAC generated with the new key inserted into the USERNAME_HMAC_2 column. If there is only a single key in use then it should insert the same username HMAC twice into both the USERNAME_HMAC_1 and USERNAME_HMAC_2 columns so that they match. This keeps the entity design simple and for relational DBs it eliminates the need for multiple tables per entity as is necessary for the List HMAC strategy. It's important to note that all search code must search for the HMAC in both columns at all times though, as it could be in either one. This leads to messier search code.</p>"},{"location":"general/general/#process-for-re-keying-data-with-the-double-hmac-strategy","title":"Process for re-keying data with the Double HMAC Strategy","text":"<ol> <li>Add your new HMAC key to the tenant's list of HMAC keys</li> <li>Wait until the HMAC key cache expiry time has passed (if applicable), so that all application instances are using the    new HMAC key.</li> <li>Kick off the re-keying job.</li> <li>The re-keying job should find each record it needs to re-key. This depends on application requirements but will    probably fall into one of 2 criteria:    a. Any record which doesn't yet have HMACs calculated with the new HMAC key - common for full re-keying of all data    **    b. Any record which has HMACs calculated with some old HMAC key (that you're trying to remove from the system), but    does not have HMACs calculated with the new HMAC key -    common for passive key rotation where no unique constraint support is required**</li> <li>For each record found, decrypt the record, calculate the HMAC(s) with the new key, overwrite the X_HMAC_2 columns (    e.g. the USERNAME_HMAC_2 column above) with the new HMAC(s).    X_HMAC_1 columns (e.g. the USERNAME_HMAC_1 column above) values should remain as they are, untouched.</li> <li>Wait for all applicable records to be re-keyed</li> <li>Remove the old HMAC key from the tenant's list of HMAC keys</li> <li>Wait until the HMAC key cache expiry time has passed (if applicable), so that all application instances are no longer    using the old HMAC key.</li> <li>Copy X_HMAC_2 column values into X_HMAC_1 columns for all fields in all records, something like:</li> </ol> <pre><code>UPDATE table\nSET USERNAME_HMAC_1 = USERNAME_HMAC_2\n</code></pre> <p>Pros of the Double HMAC strategy:</p> <ul> <li>Fairly solid HMAC design which will probably work for a good number of application requirements</li> <li>Relational DB friendly, single table design</li> <li>Negligible performance impact. Only calculates and inserts a max of 2 HMACs (per attribute) for each write operation</li> <li>Supports zero-outage search</li> <li>Supports unique constraint integrity</li> <li>Supports both the previous points for applications which cache HMAC keys</li> </ul> <p>Cons of the Double HMAC strategy:</p> <ul> <li>For applications which use HMACs for unique value enforcement and only support passive key rotation (don't re-key   data), it potentially only supports ones with relatively short   data retention</li> <li>For applications which use HMACs for unique constraint support and have long-lived data, this strategy requires   re-keying all data (by some background task) once a new HMAC key   is introduced. Once this task finishes the old key can be removed</li> <li>Introduces a small window for mistakes to be made during HMAC key rotation. A code defect could mix up the HMAC   columns which would cause issues. Or if the order of the HMAC keys   in the list of HMAC keys is wrong then this could cause serious problems</li> <li>Application search code looks awkward as searches have to look in both HMAC columns (OR query)</li> <li>Supporting HMAC tokenization would be very clunky</li> </ul> <p> </p>"},{"location":"general/general/#some-final-considerations-for-application-designs","title":"Some final considerations for application designs","text":"<p>Although corporate security guidelines in some companies may only require applications to support HMAC key rotation but not necessarily rekeying, we strongly advise application developers to reconsider this in the context of their application functionality and requirements! Supporting only HMAC key rotation for long-lived data means that there's a strong possibility that you cannot ever deprecate any of a tenant's HMAC keys. Every time you update a tenant to a new HMAC key (meaning that you add a new one into the tenant's list of keys) then your application's search operations will progressively get slower. This is because if a tenant has N HMAC keys we have to calculate N HMACs when we search for something. Since we can't remove a tenant's keys (because there may be records that have never been modified since being written with the key in use at that time) then we'll have to keep using all of them to generate HMACs for every operation until the end of time. Also, although the search challenge documented above will still be solved in a functional sense, the unique constraint  challenge will still remain a serious problem in your application (if you have unique constraint  requirements).  The only concrete way to solve the unique constraint challenge for key rotation without rekey would be to use  the List HMAC Strategy.  </p>"},{"location":"general/general/#faq","title":"FAQ","text":""},{"location":"general/general/#whats-a-tenant","title":"What's a tenant?","text":"<p>For applications which store data from different client applications or enterprises there is often the requirement that we need to segregate the data belonging to each client (i.e. your application has multiple customer enterprises which use it: Bank A, Bank B and Bank C).  Company requirements (and regulations) can sometimes dictate that the data which your application stores related to each of these customers must be logically separated from each other. This is to limit the exposure which might happen in a security breach. Your application could spin up 3 separate (and isolated) environments for each customer but this is often too costly to maintain.  An easier and equivalent way to do this is to have the concept of 'tenants' in your application. Each customer is a ' tenant' and each tenant has separate encryption keys. So your application will store and configure tenant information (which will include the details of encryption and HMAC keys for each tenant).  Each operation in your application will then be within the context of one of these tenants. Any data stored for Bank A is encrypted with an encryption key which is only used by Bank A, And similarly, any data stored for Bank B is encrypted with an encryption key which is only used by Bank B. If your system doesn't have/need the concept of tenants then you can just think of a tenant as \"the application\" in this documentation.</p>"},{"location":"general/general/#whats-a-hmac","title":"What's a HMAC?","text":"<p>A HMAC is just a hash which uses a secret key to perform the hashing operation.</p>"},{"location":"general/general/#whats-a-hash","title":"What's a hash?","text":"<p>A hash is a one-way encryption cipher. One-way means that for a given piece of data, hashing it will produce a ciphertext but that ciphertext can never be used to reproduce the original value, it can never be decrypted. Hashes are useful for storing data that needs to be matched but which we never want to risk an attacker knowing. Hashes are often used to store passwords in a secure system.</p>"},{"location":"general/general/#whats-an-iv","title":"What's an IV?","text":"<p>An IV (Initialization Vector) essentially introduces randomness into the data being encrypted. A new IV should be generated and used for every encryption operation which means that even if you encrypt the same piece of data with the same secret key, the resulting ciphertext will be different. The ciphertext will always decrypt successfully to the original data (the IV is actually stored in the clear, inside the data containing the ciphertext) but the fact that the resulting ciphertext is always unique for any encryption operation makes cryptanalysis more difficult to potential attackers.</p>"},{"location":"general/general/#why-do-i-need-to-hmac-data-in-order-to-make-it-searchable","title":"Why do I need to HMAC data in order to make it searchable?","text":"<p>When we encrypt a piece of data we should use an IV as well as the secret key - so make sure to consider using IVs in any custom EncryptionServiceDelegate implementations you create for your application. Due to the fact that each time we encrypt a piece of data it never generates the same ciphertext this means that we cannot search on that attribute. It may be tempting to think that for a search operation you could encrypt the incoming search value and look for matching ciphertext in the DB. But since the ciphertext just generated for the incoming search term is guaranteed unique (due to the use of an IV) it won't match anything. The solution is to store a HMAC value alongside any attribute that needs to be searchable. HMACs will always give the same HMAC value for the same piece of data so they can be used for search purposes. If an encrypted attribute also has a HMAC value stored separately for it, Their irreversibility makes them very secure.</p>"},{"location":"general/general/#why-do-i-need-to-hmac-confidential-data-in-order-to-make-it-unique","title":"Why do I need to HMAC confidential data in order to make it unique?","text":"<p>As explained above the encryption of confidential data always results in a unique ciphertext (due to the use of IVs) so that particular ciphertext cannot be used to enforce a unique constraint. The solution is to also store a HMAC for this attribute and place a unique constraint on that field instead.</p>"},{"location":"general/general/#what-is-a-key-rotation","title":"What is a key rotation?","text":"<p>A key rotation is the action of changing an encryption or HMAC key that you're using right now (for a tenant) to a different one.</p>"},{"location":"general/general/#why-would-i-perform-a-key-rotation","title":"Why would I perform a key rotation?","text":"<p>Many corporate and regulatory guidelines require encryption keys to be updated when certain criteria are met. The criteria definitions can sometimes be a bit fuzzy and there's no permanent concrete criteria for all applications. Some criteria are usage based, e.g. changing the key after it's been used X times. Other criteria are time based, e.g. change the key every X period. Please consult your corporate security guidance or the appropriate regulations for prescriptions on when you need to rotate encryption and HMAC keys in your application.</p> <p>The following points should also be taken into consideration when deciding when a key might need to be rotated:</p> <ul> <li>If a key becomes compromised then it is necessary to remove it from the system, which requires rotating to a new key   (most likely followed by a rekey). This could happen at any time.</li> <li>If new company or national regulations decide that the crypto period needs to be some different prescription than   current company/regulatory requirements.</li> <li>Some Cryptographic providers may stop being available in certain regions or deployment environments. In that case,   application instances deployed in those environments will have   to rotate keys onto a different cryptographic provider.</li> </ul>"},{"location":"general/general/#what-does-re-keying-mean","title":"What does re-keying mean?","text":"<p>Re-keying is where after introducing a new encryption/HMAC key, some background job goes through the database record by record, decrypting (with the old key) and re-encrypting (re-keying) with the new key(s) until there are no more records left that use the old key(s).</p>"},{"location":"general/general/#why-should-i-re-key","title":"Why should I re-key","text":"<p>If an encryption or HMAC key is compromised then you'll probably have to make sure that no data in your DB is encrypted or contains HMACs calculated with that key. This means you have to consider re-keying all the data that used that compromised key with a new encryption/HMAC key. If your application uses HMACs for data that has a long data retention policy then it's probably unrealistic to keep adding more and more HMAC keys over time but never being able to remove them from the system. With each addition of a HMAC key the performance of your application will degrade because that's one extra HMAC to calculate (and search for/and possibly store) for every HMAC operation. If your application is multi-instance, caches keys and doesn't use the List HMAC Strategy then you'll need to re-key if your application uses HMACs for unique constraint enforcement.</p>"},{"location":"general/general/#why-does-mango4j-crypto-core-have-the-concept-of-only-1-encryption-key-but-multiple-hmac-keys","title":"Why does mango4j-crypto-core have the concept of only 1 encryption key but multiple HMAC keys?","text":"<p>When a piece of data is encrypted a reference to the encryption key is contained in the actual ciphertext along with the encrypted data. This means that it will always be possible to decrypt the data even if the current encryption key is changed (i.e. for a key rotation), assuming you didn't delete the old key. HMACs however are different, HMACs don't have a reference to the HMAC key stored alongside them. So, once a HMAC key is updated/rotated to a new HMAC key, some records will have HMACs calculated using the old key (since they haven't been recalculated yet) and some records will have HMACs calculated using the new key (new records and newly updated records). This means that there will be periods where we need to perform searches using more than 1 HMAC key since we can't be sure what records have been calculated with what keys unless all HMACs in the DB are recalculated with the new key (re-keyed). This is just a re-statement of the HMAC key rotation challenges.</p> <p>In a simpler statement: To decrypt something, we have already obtained the data we need to decrypt. But HMACs are used to search for data, we don't know where it is yet. Therefore, we don't know which HMAC key might have been used to HMAC it. So we have to try all the HMAC keys to search for it.</p>"},{"location":"general/general/#why-dont-hmacs-have-a-reference-to-the-hmac-key-stored-alongside-them-the-same-way-encrypted-ciphertext-does","title":"Why don't HMACs have a reference to the HMAC key stored alongside them the same way encrypted ciphertext does?","text":"<p>Elaborating on previous statements: It would serve no real purpose to store a reference to the HMAC key beside the HMAC since they are used primarily for search purposes and by definition that means that you have no information about the row where the HMAC is or even where it is in the DB. With encrypted ciphertext it's different, you already know the row (maybe your application accessed it directly by ID, or maybe you've searched for and found it). So once you have the row then it's good that it has a reference to the encryption key that was used, so now you can use that key reference to decrypt it. With HMACs you're trying to use them to find the row in the first place and once you've found the row, having a reference to the HMAC key would serve no extra purpose. In summary, you never know where the HMAC you're looking for is or which HMAC key might have been used to calculate it, so storing the HMAC key reference alongside it won't help you with anything. And again, This is why you must try all possible HMAC keys when searching.</p> <p>Caveat: In saying that, it is useful to store a reference to the HMAC key alongside the HMAC so that re-key jobs can easily query which records need re-keyed and which do not. But this is a convenience related to re-keying performance only and is not related to normal HMAC functionality.</p>"},{"location":"general/general/#what-is-hmac-tokenization","title":"What is HMAC tokenization?","text":"<p>HMAC Tokenization is the process of chopping an input value into separate pieces and calculating HMACs for each piece for more flexible search support. i.e. for a PAN (Primary Account Number - such as Credit Card numbers) you could HMAC the full PAN, HMAC the last 4 digits of the PAN, HMAC the PAN without dashes/spaces giving a total of 3 resulting HMACs for a single input. This allows you to support richer search capabilities because now your application can support searching on the last 4 digits of the PAN and allows searches to find a PAN whether it has dashes/spaces in it or not.</p>"},{"location":"general/general/#appendixes","title":"Appendixes","text":""},{"location":"general/general/#a-decisioning-diagram-for-which-hmac-strategy-to-use","title":"A: Decisioning diagram for which HMAC strategy to use","text":""},{"location":"general/general/#b-possible-re-keying-process-when-using-list-hmac-strategy-when-the-application-need-to-delete-a-specific-hmac-key","title":"B: Possible re-keying process when using list HMAC strategy when the application need to delete a specific HMAC key","text":"<p>When your application mostly runs on key rotation without rekeying, but you need to support a process whereby a HMAC key needs to be completely removed from the system then you can follow steps similar to below:</p> <p>Terminology: Deprecated HMAC Key: HMAC key that you want to completely remove from your system.</p> <p>Substitute key: The HMAC key that was next introduced to the system after the deprecated key was originally introduced.</p> <ol> <li>Run a query which finds records that have HMACs calculated with the key that's getting removed but do not have HMACs    generated with the next most recent key (e.g. if you're    removing the oldest HMAC key then find records that have HMACs calculated with that key but have no HMACs calculated    with the second oldest key).</li> <li>For each record generate HMACs with the substitute key and save them to the record (or to both the LOOKUP and    UNIQUE_VALUES table if using separate SQL tables)</li> <li>Delete the HMAC key to be removed from the system.</li> <li>Delete the HMACs calculated with the deleted HMAC key from all records.</li> </ol>"},{"location":"general/general/#case-study-for-an-application-which-uses-the-list-hmac-strategy-and-has-the-unique-constraint-challenge","title":"Case study for an application which uses the List HMAC Strategy and has the unique constraint challenge","text":"<p>Background: ACME unique application is an application that relies solely on HMAC key rotation (without rekeying) to manage the keying of records over time. ACME application also requires unique constraints on highly confidential fields, so it uses the List HMAC Strategy. The application introduces a new HMAC key into the system every year. After 4 years it is required to remove the oldest HMAC key from the system. ACME application data is long-lived and so it's not possible to rely on data retention rules to simply delete records that used the old HMAC key so a re-keying job is necessary.</p> <ul> <li>ACME application always has 4 HMAC keys in use at any one time. Currently, it is year 8 of the application's lifetime   so the HMACs keys are HMAC_KEY_5, HMAC_KEY_6, HMAC_KEY_7,   HMAC_KEY_8. (This corresponds to the 2nd last column in the diagram below)</li> <li>At the start of year 9 (last column in the table below) a new HMAC key (HMAC_KEY_9) is introduced to the system (   meaning that temporarily there are now 5 HMAC keys in use).</li> <li>A background re-keying task is then kicked off. We need to remove HMAC_KEY_5 from the system as it's now too old.</li> <li>The re-keying job executes a batched query. This query looks for records that do not have HMACs calculated with   HMAC_KEY_6, which is now the oldest allowed HMAC key.<ul> <li>When using the List HMAC Strategy correctly, this would be records that were written up to and during the 5th year   which was the year before HMAC_KEY_6 was introduced into   the system. During that 5th year all records would have been written with keys HMAC_KEY_2, HMAC_KEY_3, HMAC_KEY_4,   HMAC_KEY_5. So those records wouldn't have any HMACs calculated   with HMAC_KEY_6. But in the year after that (year 6), the system would have keyed off the oldest HMAC key (at that   time HMAC_KEY_2) and records would have started to get written   with keys HMAC_KEY_3, HMAC_KEY_4, HMAC_KEY_5 and HMAC_KEY_6.</li> </ul> </li> <li>For each record found, the application decrypts the record, calculates any HMACS with HMAC_KEY_6 and inserts those new   HMACs into the record LOOKUP and UNIQUE_VALUES lists.</li> <li>When all records have been modified as above, HMAC_KEY_5 is deleted from the system.</li> <li>All HMAC entries that were made with HMAC_KEY_5 are removed from every record in the system.</li> </ul> <p>You can see that using this strategy that the re-keying job has to re-key an increasing number of records each year.</p> <p>Key points about the diagram above:</p> <p>In each year, HMAC keys with a strikethrough depict the deprecated HMAC keys that are getting keyed off and subsequently deleted.</p> <p>The =&gt; symbol depicts a re-key operation from the deprecated HMAC key to the next most recent HMAC key.</p> <p>Observations on the table above:</p> <p>Notice that as the years go on (as we go right through the columns) that the number of blocks with a re-key operation ( depicted using the =&gt; symbol) grows? This is a visualization of the fact that over time the re-key job will have more and more periods of records to re-key, so the re-key job will get progressively slower over time.</p> <p>Visually the diagram shows us that in order to guarantee uniqueness enforcement, all cells in a column must share at least one number. We can see that using this re-keying approach this number is always the current oldest HMAC key number.</p> <p>With keys having a rotation period of 1 year and an expiry of 4 years there will mostly be 4 active HMAC keys in use at all times (excluding the first 3 years). The only exceptions to this is when a new HMAC key is introduced there will be 5 HMAC keys in use until the re-keying job is finished and the oldest key is deleted. So each year the HMAC key list will temporarily grow to 5 keys and shrink back to 4.</p> <p>In any year, there are only ever a maximum of N-1 periods which don't need re-keying.</p> <p>The approach to using 4 HMAC keys (as in this example) might not make much sense in the end. Using 2 keys and just doing a full re-key to the new key each year would most likely make more sense. The reason being is that as the application continues in time the number of periods that need re-keyed will be much greater than the number that don't (in this case 3). But the normal day-to-day operations of the application will always need to calculate 4 HMACs for every operation (5 during a re key), which will have a negative impact on performance. If you switch to just having a single active HMAC key and changing it every year the normal performance of the app will improve as it will only have to calculate a single HMAC for every operation (2 during a re key). This will come at the expense of the re-keying job having to do 3 extra periods, which would likely be an acceptable trade off.</p>"},{"location":"guide/guide/","title":"mango4j-crypto","text":"mango4j-crypto"},{"location":"guide/guide/#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Introduction</li> <li>Getting Started</li> <li>Encryption</li> <li>CryptoKey Provider</li> <li>CryptoShield Setup</li> <li>HMAC<ol> <li>Single HMAC Strategy</li> <li>List HMAC Strategy</li> <li>HMAC Tokenizers</li> <li>Compound Unique Constraints with the List HMAC Strategy</li> <li>Single HMAC Strategy With Key Start Time</li> <li>Double HMAC Strategy</li> </ol> </li> <li>Key Rotation</li> <li>Rekeying</li> <li>Provided Encryption Service Delegates</li> <li>Testing Delegates<ol> <li>Base64EncryptionService</li> <li>IdentityEncryptionService</li> </ol> </li> <li>Production Delegates<ol> <li>PBKDF2EncryptionService</li> <li>WrappedKeyEncryptionService</li> <li>CachedWrappedKeyEncryptionService</li> <li>AWS Encryption Service</li> </ol> </li> </ol>"},{"location":"guide/guide/#annotations","title":"Annotations","text":"<p>The main annotations that developers will use are:</p>"},{"location":"guide/guide/#encrypt","title":"@Encrypt","text":"<p>The @Encrypt annotation should be placed on fields which must be encrypted. This annotation also requires the @EncryptedData partner annotation to be placed on the (single) field where the library should put the resulting ciphertext (which is generated in one go for all fields), so you only need one @EncryptedData field regardless of the number of @Encrypt fields. This is shown in the example entity code below.</p> <p>NOTE: All fields marked with @Encrypt must be transient or the library will throw an error on registration of the entity. The only exception to this is when also using the @EnabledMigrationSupport annotation during once off migration onto the library for existing applications (this will be explained further in this document).</p>"},{"location":"guide/guide/#hmac","title":"@Hmac","text":"<p>The @Hmac annotation should be placed on fields which must be HMACed for either lookup or unique constraint purposes. Depending on the HmacStrategy that your entity is using there needs to be corresponding fields where the library should  write the HMACs to. There are currently 3 HMAC strategies supported by the library and each one has slightly different  approaches related to the design of your entity. This will most certainly seem strange, but they will be discussed at length further in this documentation when it will make more sense. Also, if you're familiar with the challenges mentioned in the the official Mango4j-crypto general documentation they will make more sense.</p> <p>NOTE: All fields marked with @Hmac must be transient or the library will throw an error on registration of the entity. The only exception to this is when also using the @EnabledMigrationSupport annotation during once off migration onto the library for existing applications (this will be explained further in this document).</p>"},{"location":"guide/guide/#encrypteddata","title":"@EncryptedData","text":"<p>As discussed above, if you have any fields marked with @Encrypt then you must have a single field marked with @EncryptedData where the library will store the ciphertext for all encrypted source fields. Underneath the hood, the library serializes all original fields into a single JSON structure  which it then encrypts in a single operation.   </p>"},{"location":"guide/guide/#encryptionkeyid","title":"@EncryptionKeyId","text":"<p>This is an optional annotation which you can place on a (String) field in your entity and the library will set it to the ID of the crypto key that was used to perform the encryption. This is not necessary for decryption purposes (the CryptoKey.key ID is also stored inside the @EncryptedData anyway) but it is useful for more performant rekey query purposes so it's recommended to have this anyway as it won't hurt and can be useful later. It would basically be used to find the records which are (or aren't) using a certain encryption/HMAC key so that they can be rekeyed with the current encryption key.</p>"},{"location":"guide/guide/#getting-started","title":"Getting Started","text":"<p>The following instructions detail how to use this library. We use Springboot for our examples but that's an arbitrary choice, you'll write your application however you want. Mango4j-crypto has very few dependencies and doesn't know what  you do with your entities after encryption/decryption. An example entity is as follows:</p>"},{"location":"guide/guide/#encryption","title":"Encryption","text":"<pre><code>import ie.bitstep.mango.crypto.annotations.Encrypt;\nimport ie.bitstep.mango.crypto.annotations.EncryptedData;\nimport ie.bitstep.mango.crypto.annotations.Hmac;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\n@Entity(name = \"USER_PROFILE\")\npublic class UserProfileEntity {\n\n    @Encrypt\n    private transient String pan;\n\n    @Encrypt\n    private transient String userName;\n\n    @Encrypt\n    private transient String ethnicity;\n\n    public String getPan() {\n        return pan;\n    }\n\n    public void setPan(String pan) {\n        this.pan = pan;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getEthnicity() {\n        return ethnicity;\n    }\n\n    public void setEthnicity(String ethnicity) {\n        this.ethnicity = ethnicity;\n    }\n\n    @Id\n    @Column(name = \"ID\")\n    private String id;\n\n    @Column(name = \"FAVOURITE_COLOR\")\n    private String favouriteColor;\n\n    @Column(name = \"ENCRYPTED_DATA\")\n    @EncryptedData\n    private String encryptedData;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getFavouriteColor() {\n        return favouriteColor;\n    }\n\n    public void setFavouriteColor(String favouriteColor) {\n        this.favouriteColor = favouriteColor;\n    }\n\n}\n</code></pre> <p>NOTES: * Fields marked with @Encrypt will be bundled up into a JSON map, encrypted all at once with the remaining ciphertext     output set into the field marked with @EncryptedData (which is the only field that would then be persisted by the application) * You'll notice that we didn't bother defining getters/setters for the ENCRYPTED_DATA field.    This keeps the entity clean from the perspective of the outside world. Code outside this class only has access to    the source fields which will contain the original values. There's usually not a need for outside code to see the actual encrypted values. * Notice that the source fields are marked transient. This is a requirement and provides more safety to your application by    making sure that serialization frameworks (Jackson, Hibernate, etc.) discard these values during serialization.    The last thing you want is your ORM flushing confidential values in cleartext to the DB. * The favouriteColour field isn't confidential so it's just a plain old field that we define normally, it gets its own    column in the DB, etc.</p>"},{"location":"guide/guide/#cryptokey-provider","title":"CryptoKey Provider","text":"<p>Before we enable mango4j-crypto to encrypt/decrypt our UserProfile entity we need to create our implementation of the  CryptoKeyProvider  interface for our application. If you store your CryptoKey objects in a database it might look something like this:</p> <pre><code>package ie.bitstep.mango.examples.crypto.example.common;\n\nimport ie.bitstep.mango.crypto.core.domain.CryptoKey;\nimport ie.bitstep.mango.crypto.core.domain.CryptoKeyUsage;\nimport ie.bitstep.mango.crypto.core.providers.CryptoKeyProvider;\nimport ie.bitstep.mango.crypto.example.domain.entities.CryptoKeyEntity;\nimport ie.bitstep.mango.examples.crypto.example.repositories.CryptoKeyRepository;\nimport ie.bitstep.mango.examples.crypto.example.utils.CryptoKeyUtils;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Component\npublic class ApplicationCryptoKeyProvider implements CryptoKeyProvider {\n\n    private final CryptoKeyRepository cryptoKeyRepository;\n    private final CryptoKeyUtils cryptoKeyUtils;\n\n    public ApplicationCryptoKeyProvider(CryptoKeyRepository cryptoKeyRepository, CryptoKeyUtils cryptoKeyUtils) {\n        this.cryptoKeyRepository = cryptoKeyRepository;\n        this.cryptoKeyUtils = cryptoKeyUtils;\n    }\n\n    @Override\n    public CryptoKey getById(String id) {\n        CryptoKeyEntity cryptoKeyEntity = cryptoKeyRepository.findById(id).orElseThrow(RuntimeException::new);\n        return cryptoKeyUtils.convert(cryptoKeyEntity);\n    }\n\n    @Override\n    public CryptoKey getCurrentEncryptionKey() {\n        return cryptoKeyUtils.convert(cryptoKeyRepository.findTopByUsageOrderByCreatedDateDesc(CryptoKeyUsage.ENCRYPTION));\n    }\n\n    @Override\n    public List&lt;CryptoKey&gt; getCurrentHmacKeys() {\n        return cryptoKeyRepository.findAllByUsage(CryptoKeyUsage.HMAC).stream()\n                .filter(cryptoKeyEntity -&gt; cryptoKeyEntity.getStatus() != DELETED)\n                .map(cryptoKeyUtils::convert)\n                .collect(Collectors.toList());\n    }\n\n    @Override\n    public List&lt;CryptoKey&gt; getAllCryptoKeys() {\n        return cryptoKeyRepository.findAll().stream()\n                .filter(cryptoKeyEntity -&gt; cryptoKeyEntity.getStatus() != DELETED)\n                .map(cryptoKeyUtils::convert)\n                .collect(Collectors.toList());\n    }\n\n}\n</code></pre> <p>NOTES: * The getCurrentKey() method should return the currently active encryption key for your tenant/application.    It is called from the CryptoShield.encrypt() method to get the key it should use for the encryption (if applicable). * The getCurrentHmacKeys() should return all HMAC keys which are currently in use for your tenant/application.    This is called by CryptoShield.encrypt() and CryptoShield.generateHmacs() to get the key(s) it should use to    calculate HMACs. * This example uses the concept of statuses on the keys to keep track of which ones have been deleted.    This allows us to keep the key for a certain length of time after a rekey (and subsequent key deletion) and then    manually clean them up when we're 100% sure we don't need them. Copying this approach is up to you. * The getById() method should return the CryptoKey regardless of its status. This method is called for the    CryptoShield.decrypt() method to get the key needed to decrypt the entity. * Make sure the createdDate fields on your CryptoKeys are correctly populated. * Most CryptoKeys fields are read-only. The only fields that you should ever update are CryptoKey.lastModifiedDate and    CryptoKey.rekeyMode. Don't update the other fields!</p>"},{"location":"guide/guide/#cryptoshield-setup","title":"CryptoShield Setup","text":"<ul> <li>Finally we just need to create an instance (bean) for CryptoShield in your application config, passing in a list of all your application   entities which use @Encrypt or @Hmac, like the following:</li> </ul> <pre><code>@Bean\npublic CryptoShield cryptoShield(CryptoKeyProvider cryptoKeyProvider) {\n    return new CryptoShield.Builder()\n            .withCryptoKeyProvider(cryptoKeyProvider)\n            .withAnnotatedEntities(List.of(UserProfileEntity.class))\n            .withEncryptionServiceDelegates(List.of(new Base64EncryptionService(), new IdentityEncryptionService()))\n            .withObjectMapperFactory(new ConfigurableObjectMapperFactory())\n            .build();\n}\n</code></pre> <p>NOTES:  * In this example we're passing in instances of Base64EncryptionService and IdentityEncryptionService to make them available to the library. These come with the library for test purposes and should never be available in a production deployment. To minimise this risk it's advised to have separate config classes which run with 'prod' and 'dev' profiles. You can create your own EncryptionService classes by creating your own subclass of EncryptionServiceDelegate (just like Base64EncryptionService and IdentityEncryptionService do) which carries out encryption operations using a cryptographic provider that you use in whatever way you need. * We register our UserProfile entity (and any others) with the library using the withAnnotationEntities() method. * ConfigurableObjectMapperFactory is a default implementation of   ObjectMapperFactory    that comes with the library to provide a Jackson ObjectMapper that it can use for formatting and parsing of the ciphertext.    You can supply your own ObjectMapperFactory implementation instead if needed.</p> <p>Then your application code can encrypt your entities by calling:</p> <p><pre><code>        cryptoShield.encrypt(userProfile);\n</code></pre> And this will encrypt all the confidential fields in your entity and set the resulting ciphertext into the field marked  with @EncryptedData. </p> <p>NOTE: This encrypt operation doesn't affect the original values of the transient fields, they remain exactly as they  were (unencrypted). So you can continue working with them in your code after calling CryptoShield.encrypt(). </p> <p> Likewise, to decrypt an entity you can call:</p> <pre><code>        cryptoShield.decrypt(userProfile);\n</code></pre> <p>And this will reset all the confidential (transient) fields in your entity back to their original values.</p>"},{"location":"guide/guide/#hmac-strategies","title":"HMAC Strategies","text":"<p>A core concept in the mango4j-crypto library is that of HMAC strategies. There are various ways that an application could choose to implement key-rotation friendly HMAC functionality (please read the  general documentation for a detailed explanation of this material) and this library provides 3  HMAC Strategies out of the box.</p> <p>You can choose which ones to apply to your application entities by using the corresponding class level annotation. The library authors strongly advise application developers to consider the @ListHmacStrategy unless there are strong reasons not to. Currently, the library supports the following (in order of preference of the mango4j-crypto team):  @ListHmacStrategy  @SingleHmacStrategy  @DoubleHmacStrategy </p> <p>But we'll start with the Single HMAC Strategy as that's the easiest to understand. In this example we also need to  generate HMACs for both the pan and username fields as they both need to be searchable and username needs to be unique  in our application.</p>"},{"location":"guide/guide/#single-hmac-strategy","title":"Single HMAC Strategy","text":"<pre><code>import ie.bitstep.mango.crypto.annotations.Encrypt;\nimport ie.bitstep.mango.crypto.annotations.EncryptedData;\nimport ie.bitstep.mango.crypto.annotations.Hmac;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\n@Entity(name = \"USER_PROFILE\")\n@SingleHmacStrategy\npublic class UserProfileEntity {\n\n    @Encrypt\n    @Hmac\n    private transient String pan;\n\n    @Encrypt\n    @Hmac\n    private transient String userName;\n\n    @Encrypt\n    private transient String ethnicity;\n\n    public String getPan() {\n        return pan;\n    }\n\n    public void setPan(String pan) {\n        this.pan = pan;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getEthnicity() {\n        return ethnicity;\n    }\n\n    public void setEthnicity(String ethnicity) {\n        this.ethnicity = ethnicity;\n    }\n\n    @Id\n    @Column(name = \"ID\")\n    private String id;\n\n    @Column(name = \"FAVOURITE_COLOR\")\n    private String favouriteColor;\n\n    @Column(name = \"USERNAME_HMAC\", unique = true)\n    private String userNameHmac;\n\n    @Column(name = \"PAN_HMAC\")\n    private String panHmac;\n\n    @Column(name = \"ENCRYPTED_DATA\")\n    @EncryptedData\n    private String encryptedData;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getFavouriteColor() {\n        return favouriteColor;\n    }\n\n    public void setFavouriteColor(String favouriteColor) {\n        this.favouriteColor = favouriteColor;\n    }\n\n}\n</code></pre> <p>NOTES: * We've added the @SingleHmacStrategy annotation to the class. * We've added 2 new fields 'panHmac' and 'userNameHmac' to the entity. This is because HMACs need to be stored separately,    and the convention the SingleHmacStrategy uses is that the hmac fields must be named the same as the source fields    with the suffix 'Hmac'. So the 'pan' field gets its HMAC calculated and set into the 'panHmac' field and same for userName. * Again, you'll notice that we didn't bother defining getters/setters for the USERNAME_HMAC, PAN_HMAC fields either,    for the same reason that we didn't bother defining getters/setters for the ENCRYPTED_DATA field. * The panHmac and userNameHmac fields are persisted to the DB in our example and each have their own columns    (we're using Hibernate here).  * The USERNAME_HMAC also has a unique constraint on it.</p> <p></p>"},{"location":"guide/guide/#list-hmac-strategy","title":"List HMAC Strategy","text":"<p><pre><code>import ie.bitstep.mango.crypto.annotations.Encrypt;\nimport ie.bitstep.mango.crypto.annotations.EncryptedData;\nimport ie.bitstep.mango.crypto.annotations.EncryptionKeyId;\nimport ie.bitstep.mango.crypto.annotations.Hmac;\nimport ie.bitstep.mango.crypto.annotations.strategies.ListHmacStrategy;\nimport ie.bitstep.mango.crypto.domain.CryptoShieldHmacHolder;\nimport ie.bitstep.mango.crypto.domain.Lookup;\nimport ie.bitstep.mango.crypto.domain.Unique;\nimport ie.bitstep.mango.crypto.tokenizers.PanTokenizer;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\n\n@ListHmacStrategy\n@Document(collection = \"UserProfile\")\npublic class UserProfileEntityForListHmacStrategy implements Lookup, Unique {\n\n    @Encrypt\n    @Hmac\n    private transient String pan;\n\n    @Encrypt\n    @Hmac(purposes = {Hmac.Purposes.LOOKUP, Hmac.Purposes.UNIQUE})\n    private transient String userName;\n\n    @Encrypt\n    private transient String ethnicity;\n\n    private Collection&lt;CryptoShieldHmacHolder&gt; lookups;\n\n    private Collection&lt;CryptoShieldHmacHolder&gt; uniqueValues;\n\n    public String getPan() {\n        return pan;\n    }\n\n    public void setPan(String pan) {\n        this.pan = pan;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getEthnicity() {\n        return ethnicity;\n    }\n\n    public void setEthnicity(String ethnicity) {\n        this.ethnicity = ethnicity;\n    }\n\n    @Id\n    private String id;\n\n    private String favouriteColor;\n\n    @EncryptedData\n    private String encryptedData;\n\n    @EncryptionKeyId\n    private String encryptionKeyId;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getFavouriteColor() {\n        return favouriteColor;\n    }\n\n    public void setFavouriteColor(String favouriteColor) {\n        this.favouriteColor = favouriteColor;\n    }\n\n    @Override\n    public void setLookups(Collection&lt;CryptoShieldHmacHolder&gt; lookups) {\n        this.lookups = lookups;\n    }\n\n    @Override\n    public List&lt;CryptoShieldHmacHolder&gt; getLookups() {\n        return lookups;\n    }\n\n    @Override\n    public void setUniqueValues(Collection&lt;CryptoShieldHmacHolder&gt; uniqueValues) {\n        this.uniqueValues = uniqueValues;\n    }\n\n    @Override\n    public List&lt;CryptoShieldHmacHolder&gt; getUniqueValues() {\n        return uniqueValues;\n    }\n\n}\n</code></pre> </p> <p>The above example entity is designed for MongoDB (as it's the most suitable DB for this HMAC strategy). If you are using it with an SQL DB check out the mango4j-crypto-example demo application which does the exact same for an SQL DB.</p> <p>NOTES: * Similar to the SingleHmacStrategy sample entity, the userName field is annotated with @Hmac but here it also has a    'purposes' definition. This can have the values of Purposes.LOOKUP, Purposes.UNIQUE, or both depending on what purpose that field    is being HMACed for. If no value is specified then it defaults to Purposes.LOOKUP. * The pan field also has the @Hmac annotation but no purposes definition so it defaults to Purposes.LOOKUP * Entities which use @ListHmacStrategy must implement either the Lookup interface, the Unique interface or both. Since this entity uses     HMACs for both purposes it implements both interfaces. Having to implement these interfaces makes the List HMAC Strategy quite    different from other HMAC designs and that is shown in your entity definition. But it's also what makes it the most powerful strategy. * Unlike the other HMAC strategies this one doesn't have associated target HMAC fields with the 'Hmac' suffix. Instead,     it implements the methods getLookups() and setLookups() from     the Lookup interface and the getUniqueValues() and setUniqueValues() from the Unique interface. The library calls back     to these methods to get and set the HMACs. This is what     makes this the most powerful HMAC strategy, we can have as many HMACS for as many keys or tokenized values as needed. * If you are using HMACs for unique constraint purposes, make sure to create the appropriate unique constraint definitions on your     DB. Generally you would place a compound unique constraint on the columns representing CryptoShieldHmacHolder.alias      and CryptoShieldHmacHolder.value (and tenant ID if applicable).</p> <p>Note: When calling CryptoShield.encrypt() for entities which have been updated (as opposed to newly created), make sure that the setLookup() and setUniqueValues() methods completely replace the existing lists! Do not append to the existing lists!!!</p>"},{"location":"guide/guide/#hmac-tokenizers","title":"HMAC Tokenizers","text":"<p>If using the ListHmacStrategy for an entity you can make use of HMAC Tokenizers by specifying them in the @Hmac annotation's HmacTokenizers method. Like:</p> <pre><code>@Hmac(HmacTokenizers = {PanTokenizer.class})\nprivate transient String pan;\n</code></pre> <p>The library will then generate a series of alternative HMACs for that field using those HmacTokenizer classes. For example the PanTokenizer (which is included in the library) in the sample code above will result in the lookup HMAC list for that entity including the HMAC of the last 4 digit of the PAN, the HMAC of the first 6 digits of the PAN, the HMAC of the PAN without dashes or spaces (if there are any). These alternative representations will then be stored along with  the HMAC of the full original PAN that was supplied. The library has some standard HMAC tokenizers, please see the javadocs for each one to learn what HMAC representations they generate. Applications can supply their own HmacTokenizers with whatever tokenization logic they need by implementing the HmacTokenizer interface.  If you have created a HmacTokenizer you think would be generally useful to others please let us know and we'll add it to the library. Using HMAC Tokenizers will help applications with more flexible searching functionality and is another reason that the ListHmacFieldStrategy is the most powerful of the 3 core HMAC strategies.</p>"},{"location":"guide/guide/#compound-unique-constraints-with-the-list-hmac-strategy","title":"Compound Unique Constraints With The List HMAC Strategy","text":"<p>One extra challenge when using the List HMAC strategy is that if you have a requirement of needing to create a compound  unique constraint on a group of fields that include a HMAC field then this cannot be done the normal way. You can  create these types of constraints using the  @UniqueGroup  annotation.  You can place this annotation on each field marked with @Hmac and give them all the same name and a unique  order number (which you must never change!) and the library will calculate a single unique HMAC for them all.</p> <p>NOTE: Mixing HMAC and cleartext fields in a unique group is fine. But at least one field in the group must be marked  with @Hmac otherwise the library will throw an error on startup.</p>"},{"location":"guide/guide/#double-hmac-strategy","title":"Double HMAC Strategy","text":"<p>Please read the the official general documentation for a description  of the Double HMAC Strategy and for when you might want to use it. The entity definition when using it is similar to the  one for the Single HMAC Strategy. Below is an example entity definition.</p> <pre><code>import ie.bitstep.mango.crypto.annotations.Encrypt;\nimport ie.bitstep.mango.crypto.annotations.EncryptedData;\nimport ie.bitstep.mango.crypto.annotations.Hmac;\nimport ie.bitstep.mango.crypto.annotations.strategies.DoubleHmacStrategy;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\n@DoubleHmacStrategy\n@Entity(name = \"USER_PROFILE_ENTITY_FOR_DOUBLE_HMAC_STRATEGY\")\npublic class UserProfileEntity {\n\n    @Encrypt\n    @Hmac\n    private transient String pan;\n\n    @Encrypt\n    @Hmac\n    private transient String userName;\n\n    @Encrypt\n    private transient String ethnicity;\n\n    public String getPan() {\n        return pan;\n    }\n\n    public void setPan(String pan) {\n        this.pan = pan;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getEthnicity() {\n        return ethnicity;\n    }\n\n    public void setEthnicity(String ethnicity) {\n        this.ethnicity = ethnicity;\n    }\n\n    @Id\n    @Column(name = \"ID\")\n    private String id;\n\n    @Column(name = \"FAVOURITE_COLOR\")\n    private String favouriteColor;\n\n    @Column(name = \"USERNAME_HMAC_1\", unique = true)\n    private String userNameHmac1;\n\n    @Column(name = \"USERNAME_HMAC_2\", unique = true)\n    private String userNameHmac2;\n\n    @Column(name = \"PAN_HMAC_1\")\n    private String panHmac1;\n\n    @Column(name = \"PAN_HMAC_2\")\n    private String panHmac2;\n\n    @Column(name = \"ENCRYPTED_DATA\")\n    @EncryptedData\n    private String encryptedData;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getFavouriteColor() {\n        return favouriteColor;\n    }\n\n    public void setFavouriteColor(String favouriteColor) {\n        this.favouriteColor = favouriteColor;\n    }\n}\n</code></pre> <p>NOTES: * We've added the @DoubleHmacStrategy annotation to the class. * This entity definition is almost the same as the one for SingleHmacStrategy except that each field annotated with    @Hmac has 2 associated HMAC fields 'panHmac1'/'panHmac2' and 'userNameHmac1'/'userNameHmac2'. This is because    with the Double HMAC Strategy we need 2 HMACs to be stored separately for each HMAC source field.  * Again, you'll notice that we didn't bother defining getters/setters for the USERNAME_HMAC_1, USERNAME_HMAC_2,    PAN_HMAC_1 or PAN_HMAC_2 fields either, for the same reasons as mentioned before. * The panHmac1, panHmac2, userNameHmac1 and userNameHmac2 fields are persisted to the DB in our example and each have their own columns    (we're using Hibernate here).  * The USERNAME_HMAC_1 and USERNAME_HMAC_2 each have a unique constraint on them also. * Application search code must look for matching HMACs in both of the HMAC columns associated with each HMAC source      field. So those queries become OR queries in the case of multiple HMAC keys in use. You can see the    mango4j-examples code to see an example of what this might look like.</p> <p></p>"},{"location":"guide/guide/#key-rotation","title":"Key Rotation","text":"<p>Key rotation is almost fairly straightforward when you just think of it as an additive process. A new encryption or HMAC key is  added to the system but the old keys are left as they are. Only when no more records are left which were encrypted, or  has had HMACs calculated, with an older key should that key be removed from the system. As long as your  CryptoKeyProvider implementation works as prescribed then things should be fine.  But make sure you understand how HMACs are different...</p>"},{"location":"guide/guide/#rekeying","title":"Rekeying","text":"<p>Mango4j-crypto has built in support for rekey jobs (currently in BETA). Encryption rekeying is supported for all  entities but for HMACs the RekeyScheduler currently only supports rekeying HMACs for entities which use the List HMAC  Strategy. The configuration is as follows:</p> <ol> <li>Implement the RekeyCryptoKeyManager interface and configure an instance of it.</li> <li>For each entity that uses this library create a corresponding implementation of the RekeyService interface.</li> <li>Configure a RekeyScheduler in your config class, like so:</li> </ol> <pre><code>@Bean\npublic RekeyScheduler rekeyScheduler(CryptoShield cryptoShield,\n                                     List&lt;RekeyService&lt;?&gt;&gt; rekeyServices,\n                                     RekeyCryptoKeyManager rekeyCryptoKeyManager,\n                                     ObjectMapperFactory objectMapperFactory,\n                                     Clock clock) {\n    RekeySchedulerConfig rekeySchedulerConfig = RekeySchedulerConfig.builder()\n            // Mandatory configurations\n            .withCryptoShield(cryptoShield)\n            .withRekeyServices(rekeyServices)\n            .withRekeyCryptoKeyManager(rekeyCryptoKeyManager)\n            .withObjectMapper(objectMapperFactory.objectMapper())\n            .withClock(clock)\n            .withCryptoKeyCachePeriod(Duration.ofMinutes(60)) // IMPORTANT: Set to your key cache duration\n            .withRekeyCheckInterval(1, 24, TimeUnit.HOURS) // Check for re-key jobs once a day, starting after 1 hour\n\n            // Optional configurations\n            .withBatchInterval(Duration.ofSeconds(1)) // Pause 1 second between batches\n            .withMaximumToleratedFailuresPerExecution(50)\n            .build();\n    return new RekeyScheduler(rekeySchedulerConfig);\n}\n</code></pre> <p>The above is a once off config. Once done, it allows the application to perform rekey jobs with no extra code and without restarting the application. In order to make this periodic RekeyScheduler start rekeying entities you need to make use of the CryptoKey.rekeyMode field. Mango4j-crypto supports 2 types of rekey modes: KEY_OFF and KEY_ON. Please see the general documentation  for an explanation of these values. Once the CryptoKey.rekeyMode field is set to either KEY_ON or KEY_OFF this RekeyScheduler will trigger the rekeying process the next time it runs (defined by <code>withRekeyCheckInterval()</code> as above).</p> <p>NOTE: You can still use the RekeyScheduler to configure a rekey for any entity that only has @Encrypt fields (and doesn't have HMACs). It's just that HMAC rekey is currently only supported for entities that use the List HMAC Strategy.</p>"},{"location":"guide/guide/#encryption-service-delegates","title":"Encryption Service Delegates","text":"<p>Mango4J Crypto uses pluggable Encryption Service Delegates to carry out cryptographic operations at runtime. There are several encryption service delegates currently supported (and more to come). Please see the  delegates section for documentation on each. </p> <p>You can also create your own EncryptionServiceDelegate implementations by subclassing the EncryptionServiceDelegate class and implementing the abstract methods with your own logic using your cryptographic provider of choice.</p>"}]}